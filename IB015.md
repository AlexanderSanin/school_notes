# IB015 Neimperativní programování
* není vnitro
* Haskell & Prolog
* překladač Haskellu je ghc, interaktivní interpretr je `ghci`, neinteraktivní interpretr je `runghc` (jako Python)

> "Ti, kreří se uspokojí."

> "Prosím vás, kdybyste měli někdy pocit, že jsem někdy trapnej. Tak to je záměr."

> ze slajdů: `Přihlašovací údaje: ("xbarnat", "majen10cm")`

> "A vy mi začnete nadávat: 'Ty jsi nám lhal, ty obludo ošklivá.'"

> Nebudu vám ho... to ani ukazovat."

> `(_:_)` "To není nějaká prdelka v ASCIIart." 

> "Já se to nebojím říct nahlas: 'Nejvnějšnější dvojtečka!'"

> "3 krát 12 je 38."

> `fň :: a -> b`, `fž :: a -> b -> a`

> "Na chleba si rozdrobíte kari."

> `((.)(.))` "Nechci vědět, co za tím vidíte... ale podle mého názoru je to pěkná prasečinka"

>  K dítěti: "Jaký největší číslo umíš?" dítě: "Nekonečno!" "Ale nekonečno + 1 je větší."

## Programování pomocí funkcí

**funkce** -- předpis, jak z nějakého vstupui vytvořit nějaký výstup, přičemž tato transofrmace musí být jednoznačná.

**typ funkce** -- vymezení objektů, se kterými daná funkce pracuje, a toho, co vrací na výstup

`objemkvadru :: cislo * cislo * cislo -> cislo`

**skládání funkcí** (`.`): `(f1 . f2) x = f1 ( f2 x )` čteme f1 po f2

`rotate_and_double x = (double.rotate90r) x` <=> `rotate_and_double = double.rotate90r` (a to druhý je hezčí)

Aplikace funkce na parametr má nejvyšší prioritu. 


## Funkcionální porgramování v Haskellu
**program** = výraz + definice funkcí;
**výpočet** = úprava (zjednodušování) výrazu;
**výsledek** = hodnota (nezjednodušitelný tvar výrazu;

**lokální definice** let ... in

### Základní datové typy
Integer, Int, Float, Fractional; Char, String ([Char]); Bool

`:t hodnota` vrací datový typ hodnoty

### Víceřádková definice
```
jedna_nebo_dva :: Intefer -> Bool
jedna_nebo_dva 1 = True
jedna_nebo_dva 2 = True
jedna_nebo_dva _ = False // podrtžítko je univerzální a vyhovuje čemukoli
```
### Podmíněný výraz
`if podmínka then výraz1 else výraz2`

výraz1 a výraz2 musí být stejného datového typu!

### Infix, prefix

`3+4` vs. `(+) 3 4`

_DOMÁCÍ ÚKOL:_
Napište a spusťte program v Haskellu, který bude řešit
dělitelnost dvou čísel, tj. zeptá se uživatele na dělence, načte
ho, pak se zeptá na dělitele, kterého také načte, a sdělí
uživateli, zda je zadaný dělenec dělitelný beze zbytku zadaným
dělitelem. (viz slajdy)

# Seznamy, typy a rekurze
`:t` -- co je to za typ

## Uspořádaná n-tice
= pevně daný počet nějakých hodnot v pevně daném pořadí; prvek kartézského součinu nosných množin
* počet prvků v n-tici je předem znám
* `("xbarnat", "majen10cm")`
* jednotice a nultice se nepoužívají
* `(,) 4 3` -> `(4, 3)`

## Seznam
= posloupnost hodnot stejného charakteru
* může být prázdný, konečný i nekonečný
* data vznikají nebo se zpracovávají postupně
* `"aa"` -- seznam znaků

## Typ
= označení množiny všech hodnot dané kvality
* každá hodnota, nebo výraz má svůj typ
* definuje se typovou signaturou `"aa" :: [Char]`
* základní datové typy: Int, Integer, Float, Char, Bool
* složené typy: (Bool,Int), [Int], [Char], [[Char]],...
* funkcionální typy: Integer -> Bool, Float -> Float -> Float
* **arita funkce** -- počet parametrů funkce, podle počtu šipek
* **polymorfní typy** -- použijeme typovou proměnnou `fst :: (a,b) -> a`, typová porměnná může zastupovat i složené typy

### Typové třídy
* některé fce nevyžadují konkrétní typ, ale nepovolují libovolný typ
* Integral -- celočíselné, Num -- numerické, Ord -- uspořadatelné, Eq -- porovnatelné na ronost
* `(+) :: Num a => a -> a -> a`
* příklad do písemky: uveďte typ `(fst.snd)` -> `(a, (c, b)) -> c`

append na začátek: `4:[5,6]` -> `[4,5,6]`;
spojení dvou seznamů stejného typu `++`;
`@` pojmenování

## Datové konstruktory
* fungují jako vzory na levých stranách definice
* mapují se vždy na nejvnější výstkyt

## Rekurze
= definice funce, nebo datové struktury, s využitím sebe sama

# Funkce vyšších řádů a λ-funkce

## Funkce vyšších řádů
= funkce jejichž argumenty jsou funkce a vrací funkce

`(.) :: (a -> b) -> (c -> a) -> c -> b`

`map :: (a -> b) -> [a] -> [b  ]`

- typový kontstruktor implicitně sdružuje závorky zprava
- aplikace funce na argumenty implicitně sdružuje zleva

`:t id (+) :: Num a => a -> a -> a`

### Funkce flip
= modifikátor funkce, který donutí binární funkci přijímat argumenty v opačném pořafí

`flip (-) 8 5` -> `-3`

## Jak zabránit částečné aplikaci
Vynutím si jako první argument uspořádanou n-tici a použiji pouze 1× ->.

`krat :: Num a => a -> a -> a`

`krat1 :: Num a => (a,a) ->`

## curry, uncurry
Funkce pro změnu řádu binárních funkcí.

`curry` funkci rozdrobí
`curry :: ((a,b) -> c) -> a -> b -> c`

`uncurry` funkci slepí
`uncurry :: a -> b -> c -> ((a,b) -> c)`

## Operátorové sekce
užívají se častěji, namísto flipu
`(4+), (3/),...`

## Kombinátory
curry, uncurry, flip

### Bezparametrová definice

## Nepojmenované funkce = lambda funkce
lambdu zapisujeme jako `\` (upadla jí nožička)

`(\x -> x + x) 8` -> `16`

## Aplikační operátor $
$ pomůže odstranit závorky
f(g(h x)) = f $ g $ h x

# Redukční strategie

## Redukční krok
= úprava výrazu, v němž se některý jeho podvýraz nahradní zjednodušeným podvýrazem

## Redukční strategie
= který podvýraz vyberu (!častá otázka u státnic!)

* **striktní redukční strategie** -- zevnitř -- jako první úplně upravíme argument a pak až na něj napasujeme funkci

* **normální redukční strategie** -- zvnějšku -- nejdřív na argument napasujeme funkci a až poté jej upravíme

* **líná redukční strategie** -- normální redukční strategie, kde se stejné výrazy vyhodnocuje paralelně, využívá tzv. **referenční transperentnost** -- stejný výraz se vždy vyhodnotí na stejný výsledek. Tuto strategii využívá Haskell.

### Churchova-Rosserova věta
Výsledná hodnota ukončeného výpočtu nezáleží na redukční strategii.

Jinou strategií nedosáhnu jiného výsledků, pokud nenastane chyba. Tato věta nevylučuje různé chování, protože může nastat chyba nebo zacyklení.

### Věta o perpetualitě
Jestliže se výraz zacyklí s redukční strategií X, pak se se určitě zacyklí i při vyhodnocování striktní strategií.

### Věta o normalizaci
S normální redukční strategií vždy dojdu k výsledku (aniž bych se zacyklila), pokud existuje alespoň jedna cesta, při které se výpočet nezacyklí.


## Nekonečné datové struktury
Výraz je vyhodnocen až v okamžiku, kdy je potřebný k dalšímu výpočtu.

`jednicky = 1 : jednicky`

`take 10 (iterate (+2) 0´)`

# Seznamy
**prostý výčet**

`1:2:3:4:5:[]`

`[1,2,3,4,5]`

**hromadný výčet**

`enumFromTo 1 12 -> [1, 2, 3,...12]`

přirozená čísla `enumFrom 0` `enumFromThemTo` -- zarazí se o třetí argument

`take 10 (enuFromThen 0 3)` --> `[0, 3, 6, 9,... 27]`

**intenzionální definice seznamu**

-- prvky jsou definovány společným pravidelm

`[2*n | n <- [6..29]]`

užití kvalifokátoru (které položky ze seznamu vybrat): `[n | n <- [6..29] , odd n ]`

kartézský součin: `[ (n,m) | n <- [1,2,3] , m <- [a,b,c]]`


# Vstup/výstup
referenční transperentnost

speciální typ IO
